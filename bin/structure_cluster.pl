=head1 NAME
 
B<structure_cluster.pl> - Run structure in parallel.
 
=head1 DESCRIPTION

This program runs structure in parallel using a given number of cpu cores as input.
 
=cut

#!/usr/bin/perl
use warnings;
use strict;
use Getopt::Long;

use POSIX qw(strftime);

use Parallel::Loops;
use IPC::Open3;
use File::Basename;
use File::Copy;

# perl structure_cluster.pl -i ~/workspace/structure_cluster/run_input/structure.stru -m ~/workspace/structure_cluster/pb/mainparams -e ~/workspace/structure_cluster/pb/extraparams -o ~/workspace/structure_cluster/run_output
# perl structure_cluster.pl -i ~/structure_cluster/run_input/structure.stru -m ~/structure_cluster/run_input/mainparams -e ~/structure_cluster/run_input/extraparams -o ~/structure_cluster/run_output

my ($structure_infile, $cpu_cores, $max_pops, $num_loci, $num_inds, $seed, $mainparams, $extraparams, $stratparams, $output_dir);
GetOptions(
	'i=s'    => \$structure_infile,
	'c=s'    => \$cpu_cores,
	'k=s'    => \$max_pops,
#	'l=s'    => \$num_loci,
	'n=s'    => \$num_inds,
#	'd=s'    => \$seed,
	'm=s'    => \$mainparams,
	'e=s'    => \$extraparams,
#	's=s'    => \$stratparams,
	'o=s'    => \$output_dir,
);

my $structure =     '/usr/local/bin/structure';

usage() unless (
	defined $structure_infile
	and defined $output_dir
);

$cpu_cores = 2 unless defined $max_pops;
$max_pops = 2 unless defined $max_pops;
# $num_loci = "" unless defined $num_loci;
$num_inds = 10 unless defined $num_inds;
# $seed = "" unless defined $seed;
# $mainparams = "" unless defined $mainparams;
# $extraparams = "" unless defined $extraparams;
# $stratparams = "" unless defined $stratparams;

sub usage {

die <<"USAGE";

Usage: $0 -i structure_infile -c cpu_cores -k max_pops -n num_inds -m mainparams -e extraparams -o output_dir
    
Description - This program runs structure in parallel using a given number of cpu cores as input.

OPTIONS:

-i structure_infile - Absolute path to the structure input file. i.e. /home/username/structure_input/structure.stru

-c cpu_cores - Number of CPU cores to use. Default: 2

-k max_pops - K value or maximum number of populations. Default: 2

#-l num_loci - not in use

-n num_inds - Number of iterations. Default: 10

#-d seed - not in use

-m mainparams - Absolute path to the mainparams input file. i.e. /home/username/structure_input/mainparams

-e extraparams - Absolute path to the extraparams input file. i.e. /home/username/structure_input/extraparams

#-s stratparams - not in use

-o output_dir - Absolute path to the output results directory. i.e. /home/username/structure_output

USAGE
}

# Create output directory if it doesn't already exist.
unless(-d $output_dir){
	mkdir($output_dir, 0777) or die "Can't make directory: $!";
}

# my $time_stamp = strftime("%a %b %e %Y %H:%M:%S", localtime);
# warn "Started on $time_stamp\n";

my $structure_filename = fileparse($structure_infile);

my ($structure_outfiles,$structure_metadata) = generate_structure_metadata($structure_filename,$mainparams,$extraparams,$output_dir);


if (require Parallel::Loops){
    #         warn "We are running in parallel!!!!\n";
    my $parallel = Parallel::Loops->new($cpu_cores);
    #         my %shared_structure_metadata = %{$structure_metadata};
    #         $parallel->share(\%shared_structure_metadata);

    #             print $structure_metadata->{$structure_filename}->{"mainparams"} . "\n";
    my @num_iterations = (0..(scalar(@{$structure_outfiles}) - 1));
    $parallel->foreach(\@num_iterations, sub {
        my $i = $_;
        my $structure_outfile = $$structure_outfiles[$i];
        my $structure_run_filename = fileparse($structure_outfile);
        my $num_pops = $1 if($structure_run_filename =~ m/K\.(\d+)\.out\.iter\.\d+/);
        my($mainparams, $extraparams) = ($structure_metadata->{$structure_run_filename}->{"mainparams"},$structure_metadata->{$structure_run_filename}->{"extraparams"});

        execute_structure($structure_infile, $num_pops, $mainparams, $extraparams, $structure_outfile, $output_dir);
    });
    undef $parallel;
}

# $time_stamp = strftime("%a %b %e %Y %H:%M:%S", localtime);
# warn "$0 terminated without errors on $time_stamp\n";

=head1 SUBROUTINES
 
(\@structure_outfiles,\%structure_metadata) = generate_structure_metadata($structure_filename,$mainparams,$extraparams,$output_dir) - Generates more than one copy of the mainparams and extraparams files because parallel processing didn't allow sharing the same files between commands. 


Input paramater(s):
 
$structure_filename - structure file name

$mainparams - mainparams input file

$extraparams - extraparams input file

$output_dir - output directory
 
Output paramater(s):

\@structure_outfiles - An array reference containing all the files generated by each K value and iteration number.
 
\%structure_metadata - The names of the mainparams and extraparams file copies based on the K value and iteration number file.
 - $structure_metadata{$structure_run_filename}{"mainparams"};
 - $structure_metadata{$structure_run_filename}{"extraparams"};
=cut
sub generate_structure_metadata{
    
    my $structure_filename = shift;
    die "Error lost structure file name" unless defined $structure_filename;
    my $mainparams = shift;
    die "Error lost mainparams input file" unless defined $mainparams;
    my $extraparams = shift;
    die "Error lost extraparams input file" unless defined $extraparams;
    my $output_dir = shift;
    die "Error lost output directory" unless defined $output_dir;
    
    my @structure_outfiles = ();
    my %structure_metadata = ();
    for(my $i = 1; $i <= $max_pops; $i++){
        for(my $j = 1; $j <= $num_inds; $j++){
            my $run_filename = join(".", "K", $i, "out", "iter",$j);
            my $structure_run_filename = join("_", $structure_filename, $run_filename);
            my $structure_outfile = join('/', $output_dir, $structure_run_filename);
            push(@structure_outfiles, $structure_outfile);
            
            $structure_metadata{$structure_run_filename}{"mainparams"} = join("_", $mainparams, $run_filename);
            my $mainparams_copy = $structure_metadata{$structure_run_filename}{"mainparams"};
            warn "copying $mainparams to $mainparams_copy\n";
            copy($mainparams,$mainparams_copy) or die "Copy failed: $!";
            $structure_metadata{$structure_run_filename}{"extraparams"} = join("_", $extraparams, $run_filename);
            my $extraparams_copy = $structure_metadata{$structure_run_filename}{"extraparams"};
            warn "copying $extraparams to $extraparams_copy\n";
            copy($extraparams,$extraparams_copy) or die "Copy failed: $!";
        }
    }
    return (\@structure_outfiles,\%structure_metadata);
}

# We had to generate more than one copy of mainparams and extraparams files because parallel processing didn't allow sharing the same files between commands.
# So we are unlinking extra copies we don't need anymore
foreach my $structure_run_filename (sort keys %{$structure_metadata}){
	my $mainparams = $structure_metadata->{$structure_run_filename}->{"mainparams"};
	warn "removing $mainparams mainparams copy using unlink\n";
	unlink($mainparams) or die "Unable to unlink $mainparams: $!";
	my $extraparams = $structure_metadata->{$structure_run_filename}->{"extraparams"};
	warn "removing $extraparams extraparams copy using unlink\n";
	unlink($extraparams) or die "Unable to unlink $extraparams: $!";
}

=pod
 
execute_structure($structure_infile,$num_pops,$mainparams,$extraparams,$structure_outfile,$top_output_dir) - Execute the structure command with the following options.

Input paramater(s):
 
$structure_infile - structure input file

$num_pops - number of populations

$mainparams - mainparams input file

$extraparams -extraparams input file

$structure_outfile - structure input file

$top_output_dir - top level directory

=cut
sub execute_structure{

	my $structure_infile = shift;
	die "Error lost structure input file" unless defined $structure_infile;
	my $num_pops = shift;
	die "Error lost number of populations" unless defined $num_pops;
	my $mainparams = shift;
	die "Error lost mainparams input file" unless defined $mainparams;
	my $extraparams = shift;
	die "Error lost extraparams input file" unless defined $extraparams;
	my $structure_outfile = shift;
	die "Error lost structure input file" unless defined $structure_outfile;
	my $top_output_dir = shift;
	die "Error lost top level directory" unless defined $top_output_dir;

	my ($structure_run_filename, $structure_output_dir) = fileparse($structure_outfile);
		
	my $structure_cmd = "$structure -i $structure_infile -K $num_pops -m $mainparams -e $extraparams -o $structure_outfile";
	warn $structure_cmd . "\n\n";

	local (*STRUCTURE_IN, *STRUCTURE_OUT, *STRUCTURE_ERR);
	my $pid = open3(\*STRUCTURE_IN, \*STRUCTURE_OUT, \*STRUCTURE_ERR, $structure_cmd) or die "Error calling open3 for structure process: $!";
	close STRUCTURE_IN or die "Error closing STDIN to structure process: $!";
      
        my $log_output_dir = join('/', $top_output_dir, "STRUCTURE_LOGFILES");
	unless(-d $log_output_dir){
		mkdir($log_output_dir, 0777) or die "Can't make directory: $!";
	}
      
	my $structure_stdout_logfile = join('/', $log_output_dir, $structure_run_filename . ".log");
	open(OUTFILE, ">$structure_stdout_logfile") or die "Couldn't open file $structure_stdout_logfile for writting, $!";
	while (<STRUCTURE_OUT>){ 
		chomp $_;
		print OUTFILE $_ . "\n";
	}
	close STRUCTURE_OUT or die "Error closing STDOUT from structure process: $!";
	close(OUTFILE) or die "Couldn't close file $structure_stdout_logfile";

	my $err_output_dir = join('/', $top_output_dir, "STRUCTURE_ERRFILES");
	unless(-d $err_output_dir){
		mkdir($err_output_dir, 0777) or die "Can't make directory: $!";
	}
      
	my $structure_err_logfile = join('/', $err_output_dir, $structure_run_filename . ".err");
	open(OUTFILE, ">$structure_err_logfile") or die "Couldn't open file $structure_err_logfile for writting, $!";
	while (<STRUCTURE_ERR>){ 
		chomp $_;
		print OUTFILE $_ . "\n";
	}
	close STRUCTURE_ERR or die "Error closing STERR from structure process: $!";
	close(OUTFILE) or die "Couldn't close file $structure_err_logfile";
	wait;
}

=head1 SYNOPSIS
 
 B<Usage:> perl structure_cluster.pl -i structure_infile -c cpu_cores -k max_pops -n num_inds -m mainparams -e extraparams -o output_dir
 
 e.g. perl structure_cluster.pl -i /home/username/structure_input/structure.stru -c 2 -k 2 -n 10 -m /home/username/structure_input/mainparams -e /home/username/structure_input/extraparams -o /home/username/structure_output
 
 B<OPTIONS:>
 
 -i structure_infile - Absolute path to the structure input file. i.e. /home/username/structure_input/structure.stru

-c cpu_cores - Number of CPU cores to use. Default: 2

-k max_pops - K value or maximum number of populations. Default: 2

#-l num_loci - not in use

-n num_inds - Number of iterations. Default: 10

#-d seed - not in use

-m mainparams - Absolute path to the mainparams input file. i.e. /home/username/structure_input/mainparams

-e extraparams - Absolute path to the extraparams input file. i.e. /home/username/structure_input/extraparams

#-s stratparams - not in use

-o output_dir - Absolute path to the output results directory. i.e. /home/username/structure_output

 =head1 COPYRIGHT
 
 B<Copyright (C) 2014  Kevin Muirhead>
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but B<WITHOUT ANY WARRANTY>; without even the implied warranty of
 B<MERCHANTABILITY> or B<FITNESS FOR A PARTICULAR PURPOSE>.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see L<http://www.gnu.org/licenses/>.
 
=cut